<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>13集合 | 程序员卖剩鸭</title>
  <meta name="keywords" content=" JavaSE ">
  <meta name="description" content="13集合 | 程序员卖剩鸭">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="Sorry！没有你想要的内容错误代码：404">
<meta property="og:type" content="website">
<meta property="og:title" content="404">
<meta property="og:url" content="http://lsqstudy.github.io/404.html">
<meta property="og:site_name" content="程序员卖剩鸭">
<meta property="og:description" content="Sorry！没有你想要的内容错误代码：404">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-11-04T15:36:29.767Z">
<meta property="article:modified_time" content="2020-07-06T12:00:04.000Z">
<meta property="article:author" content="程序员卖剩鸭">
<meta name="twitter:card" content="summary">


<link rel="icon" href="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2020/04/17/20200418164903.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="程序员卖剩鸭" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>


<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2020/04/17/20200418164903.jpg"/>
</a>
<div class="author">
    <span>程序员卖剩鸭</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/lsqstudy"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="jianshu"
               href="https://www.jianshu.com/u/34fa573ae2b2"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-jianshu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/lsqstudy"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="csdn"
               href="https://me.csdn.net/PorkBird"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-csdn"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=1823472446@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(3)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="学习笔记">
                        <i class="fold iconfont icon-right"></i>
                        
                        学习笔记
                        <small>(1)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="学习笔记<--->JavaSE">
                                        
                                        JavaSE
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="音乐MV">
                        <i class="fold iconfont icon-right"></i>
                        
                        音乐MV
                        <small>(1)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="音乐MV<--->韩国">
                                        
                                        韩国
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="3">
<input type="hidden" id="yelog_site_word_count" value="16.9k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://blog.csdn.net/PorkBird/article/details/113666639?spm=1001.2014.3001.5501">CSDN</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JavaSE</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>音乐</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a id="top" class="全部文章 音乐MV 韩国 "
           href="/post/d76a15aa1.html"
           data-tag="音乐"
           data-author="" >
            <span class="post-title" title="IU神级演唱现场">IU神级演唱现场</span>
            <span class="post-date" title="2022-11-19 00:00:00">2022/11/19</span>
        </a>
        
        <a  class="全部文章 "
           href="/post/aa7c3fd8.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="lsq01_Document/01学习视频">lsq01_Document/01学习视频</span>
            <span class="post-date" title="2022-11-20 12:46:05">2022/11/20</span>
        </a>
        
        <a  class="全部文章 学习笔记 JavaSE "
           href="/post/d76a15aa.html"
           data-tag="JavaSE"
           data-author="" >
            <span class="post-title" title="13集合">13集合</span>
            <span class="post-date" title="2020-07-27 00:00:00">2020/07/27</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-lsq01_Document/03集合" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">13集合</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="学习笔记">学习笔记</a> > 
            
            <a  data-rel="学习笔记&lt;---&gt;JavaSE">JavaSE</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color2">JavaSE</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2022-11-19 22:57:15'>2020-07-27 00:00</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:16.8k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#01、Java-集合框架概述"><span class="toc-text">01、Java 集合框架概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1、集合框架与数组的对比及概述"><span class="toc-text">1.1、集合框架与数组的对比及概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2、集合框架涉及到的API"><span class="toc-text">1.2、集合框架涉及到的API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#02、Collection接口方法"><span class="toc-text">02、Collection接口方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2、Collection接口中的常用方法1"><span class="toc-text">2.2、Collection接口中的常用方法1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3、Collection接口中的常用方法2"><span class="toc-text">2.3、Collection接口中的常用方法2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4、Collection接口中的常用方法3"><span class="toc-text">2.4、Collection接口中的常用方法3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5、Collection接口中的常用方法4"><span class="toc-text">2.5、Collection接口中的常用方法4</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#03、Iterator迭代器接口"><span class="toc-text">03、Iterator迭代器接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1、使用Iterator遍历Collection"><span class="toc-text">3.1、使用Iterator遍历Collection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2、迭代器Iterator的执行原理"><span class="toc-text">3.2、迭代器Iterator的执行原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3、Iterator遍历集合的两种错误写法"><span class="toc-text">3.3、Iterator遍历集合的两种错误写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4、Iterator迭代器remove-的使用"><span class="toc-text">3.4、Iterator迭代器remove()的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5、新特性foreach循环遍历集合或数组"><span class="toc-text">3.5、新特性foreach循环遍历集合或数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#04、Collection子接口之一：List接口"><span class="toc-text">04、Collection子接口之一：List接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1、List接口常用实现类的对比"><span class="toc-text">4.1、List接口常用实现类的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2、ArrayList的源码分析"><span class="toc-text">4.2、ArrayList的源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3、LinkedList的源码分析"><span class="toc-text">4.3、LinkedList的源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4、Vector的源码分析"><span class="toc-text">4.4、Vector的源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5、List接口中的常用方法测试"><span class="toc-text">4.5、List接口中的常用方法测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6、List的一个面试小题"><span class="toc-text">4.6、List的一个面试小题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#05、Collection子接口之二：Set接口"><span class="toc-text">05、Collection子接口之二：Set接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1、Set接口实现类的对比"><span class="toc-text">5.1、Set接口实现类的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2、Set的无序性与不可重复性的理解"><span class="toc-text">5.2、Set的无序性与不可重复性的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3、HashSet中元素的添加过程"><span class="toc-text">5.3、HashSet中元素的添加过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4、关于hashCode-和equals-的重写"><span class="toc-text">5.4、关于hashCode()和equals()的重写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1、重写hashCode-方法的基本原则"><span class="toc-text">5.4.1、重写hashCode() 方法的基本原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2、重写equals-方法的基本原则"><span class="toc-text">5.4.2、重写equals() 方法的基本原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3、Eclipse-IDEA工具里hashCode-的重写"><span class="toc-text">5.4.3、Eclipse&#x2F;IDEA工具里hashCode()的重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5、LinkedHashSet的使用"><span class="toc-text">5.5、LinkedHashSet的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6、TreeSet的自然排序"><span class="toc-text">5.6、TreeSet的自然排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7、TreeSet的定制排序"><span class="toc-text">5.7、TreeSet的定制排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8、TreeSet的课后练习"><span class="toc-text">5.8、TreeSet的课后练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9、Set课后两道面试题"><span class="toc-text">5.9、Set课后两道面试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#06、Map接口"><span class="toc-text">06、Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1、Map接口及其多个实现类的对比"><span class="toc-text">6.1、Map接口及其多个实现类的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2、Map中存储的key-value的特点"><span class="toc-text">6.2、Map中存储的key-value的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3、Map实现类之一：HashMap"><span class="toc-text">6.3、Map实现类之一：HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4、HashMap的底层实现原理"><span class="toc-text">6.4、HashMap的底层实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1、HashMap在JDK7中的底层实现原理"><span class="toc-text">6.4.1、HashMap在JDK7中的底层实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2、HashMap在JDK8中的底层实现原理"><span class="toc-text">6.4.2、HashMap在JDK8中的底层实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7、LinkedHashMap的底层实现原理（了解）"><span class="toc-text">6.7、LinkedHashMap的底层实现原理（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8、Map中的常用方法1"><span class="toc-text">6.8、Map中的常用方法1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9、Map中的常用方法2"><span class="toc-text">6.9、Map中的常用方法2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10、TreeMap两种添加方式的使用"><span class="toc-text">6.10、TreeMap两种添加方式的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-12、Hashtable"><span class="toc-text">6.12、Hashtable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-13、Properties处理属性文件"><span class="toc-text">6.13、Properties处理属性文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#07、Collections工具类"><span class="toc-text">07、Collections工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1、Collections工具类常用方法的测试"><span class="toc-text">7.1、Collections工具类常用方法的测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2、补充：Enumeration-了解！！！"><span class="toc-text">7.2、补充：Enumeration(了解！！！)</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="01、Java-集合框架概述"><a href="#01、Java-集合框架概述" class="headerlink" title="01、Java 集合框架概述"></a>01、Java 集合框架概述</h1><h2 id="1-1、集合框架与数组的对比及概述"><a href="#1-1、集合框架与数组的对比及概述" class="headerlink" title="1.1、集合框架与数组的对比及概述"></a>1.1、集合框架与数组的对比及概述</h2><pre><code class="java">/**
 * 一、集合的框架
 *
 * 1.集合、数组都是对多个数据进行存储操作的结构，简称Java容器。
 *   说明；此时的存储，主要是指能存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi,数据库中）
 *
 * 2.1数组在存储多个数据封面的特点：
 *      》一旦初始化以后，它的长度就确定了。
 *      》数组一旦定义好，它的数据类型也就确定了。我们就只能操作指定类型的数据了。
 *      比如：String[] arr;int[] str;
 * 2.2数组在存储多个数据方面的特点：
 *      》一旦初始化以后，其长度就不可修改。
 *      》数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。
 *      》获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用
 *      》数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。
 *
 */</code></pre>
<blockquote>
<p>1、集合的使用场景</p>
</blockquote>
<p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183451.png" alt=""><br><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183455.png" alt=""></p>
<h2 id="1-2、集合框架涉及到的API"><a href="#1-2、集合框架涉及到的API" class="headerlink" title="1.2、集合框架涉及到的API"></a>1.2、集合框架涉及到的API</h2><ul>
<li>Java 集合可分为<code>Collection</code>和<code>Map</code>两种体系<ul>
<li><code>Collection</code>接口：单列数据，定义了存取一组对象的方法的集合<ul>
<li><code>List</code>：元素有序、可重复的集合</li>
<li><code>Set</code>：元素无序、不可重复的集合</li>
</ul>
</li>
<li><code>Map</code>接口：双列数据，保存具有映射关系“key-value对”的集合</li>
</ul>
</li>
</ul>
<blockquote>
<p>1、<strong>Collection接口继承树</strong></p>
</blockquote>
<p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183459.png" alt=""></p>
<blockquote>
<p>2、<strong>Map接口继承树</strong></p>
</blockquote>
<p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183503.png" alt=""></p>
<pre><code class="java">/**
 *
 * 二、集合框架
 *      &amp;---Collection接口：单列集合，用来存储一个一个的对象
 *          &amp;---List接口：存储有序的、可重复的数据。  --&gt;“动态”数组
 *              &amp;---ArrayList、LinkedList、Vector
 *
 *          &amp;---Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”
 *              &amp;---HashSet、LinkedHashSet、TreeSet
 *
 *      &amp;---Map接口：双列集合，用来存储一对(key - value)一对的数据   --&gt;高中函数：y = f(x)
 *          &amp;---HashMap、LinkedHashMap、TreeMap、Hashtable、Properties
 *
 */</code></pre>
<h1 id="02、Collection接口方法"><a href="#02、Collection接口方法" class="headerlink" title="02、Collection接口方法"></a>02、Collection接口方法</h1><ul>
<li>Collection 接口是List、Set 和Queue 接口的父接口，该接口里定义的方法既可用于操作Set 集合，也可用于操作List 和Queue 集合。</li>
<li>JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。</li>
<li>在Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成Object 类型处理；从JDK 5.0 增加了<strong>泛型</strong>以后，Java 集合可以记住容器中对象的数据类型。</li>
</ul>
<h2 id="2-2、Collection接口中的常用方法1"><a href="#2-2、Collection接口中的常用方法1" class="headerlink" title="2.2、Collection接口中的常用方法1"></a>2.2、Collection接口中的常用方法1</h2><ol>
<li>添加<ul>
<li>add(Objec tobj)</li>
<li>addAll(Collection coll)</li>
</ul>
</li>
<li>获取有效元素的个数<ul>
<li>int size()</li>
</ul>
</li>
<li>清空集合<ul>
<li>void clear()</li>
</ul>
</li>
<li>是否是空集合<ul>
<li>boolean isEmpty()</li>
</ul>
</li>
<li>是否包含某个元素<ul>
<li>boolean contains(Object obj)：是通过元素的equals方法来判断是否是同一个对象</li>
<li>boolean containsAll(Collection c)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。</li>
</ul>
</li>
<li>删除<ul>
<li>boolean remove(Object obj) ：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素</li>
<li>boolean removeAll(Collection coll)：取当前集合的差集</li>
</ul>
</li>
<li>取两个集合的交集<ul>
<li>boolean retainAll(Collection c)：把交集的结果存在当前集合中，不影响c</li>
</ul>
</li>
<li>集合是否相等<ul>
<li>boolean equals(Object obj)</li>
</ul>
</li>
<li>转成对象数组<ul>
<li>Object[] toArray()</li>
</ul>
</li>
<li>获取集合对象的哈希值<ul>
<li>hashCode()</li>
</ul>
</li>
<li>遍历<ul>
<li>iterator()：返回迭代器对象，用于集合遍历</li>
</ul>
</li>
</ol>
<pre><code class="java">import org.junit.Test;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;

/**
 *
 * 三、Collection接口中的方法的使用
 *
 */
public class CollectionTest {

    @Test
    public void test1(){
        Collection coll = new ArrayList();

        //add(Object e):将元素e添加到集合coll中
        coll.add(&quot;AA&quot;);
        coll.add(&quot;BB&quot;);
        coll.add(123);  //自动装箱
        coll.add(new Date());

        //size():获取添加的元素的个数
        System.out.println(coll.size());    //4

        //addAll(Collection coll1):将coll1集合中的元素添加到当前的集合中
        Collection coll1 = new ArrayList();
        coll1.add(456);
        coll1.add(&quot;CC&quot;);
        coll.addAll(coll1);

        System.out.println(coll.size());    //6
        System.out.println(coll);

        //clear():清空集合元素
        coll.clear();

        //isEmpty():判断当前集合是否为空
        System.out.println(coll.isEmpty());
    }
}</code></pre>
<h2 id="2-3、Collection接口中的常用方法2"><a href="#2-3、Collection接口中的常用方法2" class="headerlink" title="2.3、Collection接口中的常用方法2"></a>2.3、Collection接口中的常用方法2</h2><blockquote>
<p>1、Person类</p>
</blockquote>
<pre><code class="java">import java.util.Objects;

public class Person {

    private String name;
    private int age;

    public Person() {
        super();
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;}&#39;;
    }

    @Override
    public boolean equals(Object o) {
        System.out.println(&quot;Person equals()....&quot;);
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &amp;&amp;
                Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {

        return Objects.hash(name, age);
    }
}</code></pre>
<blockquote>
<p>2、测试类</p>
</blockquote>
<pre><code class="java">import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;

/**
 * Collection接口中声明的方法的测试
 *
 * 结论：
 * 向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().
 */
public class CollectinoTest {

    @Test
    public void test(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);

//        Person p = new Person(&quot;Jerry&quot;,20);
//        coll.add(p);
        coll.add(new Person(&quot;Jerry&quot;,20));

        coll.add(new String(&quot;Tom&quot;));
        coll.add(false);

        //1.contains(Object obj):判断当前集合中是否包含obj
        //我们在判断时会调用obj对象所在类的equals()。
        boolean contains = coll.contains(123);
        System.out.println(contains);
        System.out.println(coll.contains(new String(&quot;Tam&quot;)));
//        System.out.println(coll.contains(p));//true
        System.out.println(coll.contains(new Person(&quot;Jerry&quot;,20)));//false --&gt;true

        //2.containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在于当前集合中。
        Collection coll1 = Arrays.asList(123,4567);
        System.out.println(coll.containsAll(coll1));
    }

}</code></pre>
<h2 id="2-4、Collection接口中的常用方法3"><a href="#2-4、Collection接口中的常用方法3" class="headerlink" title="2.4、Collection接口中的常用方法3"></a>2.4、Collection接口中的常用方法3</h2><blockquote>
<p>1、Person类</p>
</blockquote>
<pre><code class="java">import java.util.Objects;

public class Person {

    private String name;
    private int age;

    public Person() {
        super();
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;}&#39;;
    }

    @Override
    public boolean equals(Object o) {
        System.out.println(&quot;Person equals()....&quot;);
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &amp;&amp;
                Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {

        return Objects.hash(name, age);
    }
}</code></pre>
<blockquote>
<p>2、测试类</p>
</blockquote>
<pre><code class="java">import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;

/**
 * Collection接口中声明的方法的测试
 *
 * 结论：
 * 向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().
 *
 */
public class CollectinoTest {

    @Test
    public void test2(){
        //3.remove(Object obj):从当前集合中移除obj元素。
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person(&quot;Jerry&quot;,20));
        coll.add(new String(&quot;Tom&quot;));
        coll.add(false);

        coll.remove(1234);
        System.out.println(coll);

        coll.remove(new Person(&quot;Jerry&quot;,20));
        System.out.println(coll);

        //4. removeAll(Collection coll1):差集：从当前集合中移除coll1中所有的元素。
        Collection coll1 = Arrays.asList(123,456);
        coll.removeAll(coll1);
        System.out.println(coll);
    }

    @Test
    public void test3(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person(&quot;Jerry&quot;,20));
        coll.add(new String(&quot;Tom&quot;));
        coll.add(false);

        //5.retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，并返回给当前集合
//        Collection coll1 = Arrays.asList(123,456,789);
//        coll.retainAll(coll1);
//        System.out.println(coll);

        //6.equals(Object obj):要想返回true，需要当前集合和形参集合的元素都相同。
        Collection coll1 = new ArrayList();
        coll1.add(456);
        coll1.add(123);
        coll1.add(new Person(&quot;Jerry&quot;,20));
        coll1.add(new String(&quot;Tom&quot;));
        coll1.add(false);

        System.out.println(coll.equals(coll1));
    }

}</code></pre>
<h2 id="2-5、Collection接口中的常用方法4"><a href="#2-5、Collection接口中的常用方法4" class="headerlink" title="2.5、Collection接口中的常用方法4"></a>2.5、Collection接口中的常用方法4</h2><blockquote>
<p>1、Person类</p>
</blockquote>
<pre><code class="java">import java.util.Objects;

public class Person {

    private String name;
    private int age;

    public Person() {
        super();
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;}&#39;;
    }

    @Override
    public boolean equals(Object o) {
        System.out.println(&quot;Person equals()....&quot;);
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &amp;&amp;
                Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {

        return Objects.hash(name, age);
    }
}</code></pre>
<blockquote>
<p>2、测试类</p>
</blockquote>
<pre><code class="java">import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

/**
 * Collection接口中声明的方法的测试
 *
 * 结论：
 * 向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().
 *
 */
public class CollectinoTest {

    @Test
    public void test4(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person(&quot;Jerry&quot;,20));
        coll.add(new String(&quot;Tom&quot;));
        coll.add(false);

        //7.hashCode():返回当前对象的哈希值
        System.out.println(coll.hashCode());

        //8.集合 ---&gt;数组：toArray()
        Object[] arr = coll.toArray();
        for(int i = 0;i &lt; arr.length;i++){
            System.out.println(arr[i]);
        }

        //拓展：数组 ---&gt;集合:调用Arrays类的静态方法asList()
        List&lt;String&gt; list = Arrays.asList(new String[]{&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;});
        System.out.println(list);

        List arr1 = Arrays.asList(123, 456);
        System.out.println(arr1);//[123, 456]

        List arr2 = Arrays.asList(new int[]{123, 456});
        System.out.println(arr2.size());//1

        List arr3 = Arrays.asList(new Integer[]{123, 456});
        System.out.println(arr3.size());//2

        //9.iterator():返回Iterator接口的实例，用于遍历集合元素。放在IteratorTest.java中测试
    }
}</code></pre>
<h1 id="03、Iterator迭代器接口"><a href="#03、Iterator迭代器接口" class="headerlink" title="03、Iterator迭代器接口"></a>03、Iterator迭代器接口</h1><ul>
<li>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历Collection 集合中的元素。</li>
<li>GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。<strong>迭代器模式，就是为容器而生</strong>。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。</li>
<li>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。</li>
<li><strong>Iterator 仅用于遍历集合</strong>，Iterator本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。</li>
<li><strong>集合对象每次调用iterator()方法都得到一个全新的迭代器对象</strong>，默认游标都在集合的第一个元素之前。</li>
</ul>
<p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183522.png" alt=""></p>
<h2 id="3-1、使用Iterator遍历Collection"><a href="#3-1、使用Iterator遍历Collection" class="headerlink" title="3.1、使用Iterator遍历Collection"></a>3.1、使用Iterator遍历Collection</h2><pre><code class="java">import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

/**
 * 集合元素的遍历操作，使用迭代器Iterator接口
 * 内部的方法：hasNext()和 next()
 *
 */
public class IteratorTest {

    @Test
    public void test(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person(&quot;Jerry&quot;,20));
        coll.add(new String(&quot;Tom&quot;));
        coll.add(false);

        Iterator iterator = coll.iterator();

        //方式一：
//        System.out.println(iterator.next());
//        System.out.println(iterator.next());
//        System.out.println(iterator.next());
//        System.out.println(iterator.next());
//        System.out.println(iterator.next());
//        //报异常：NoSuchElementException
//        //因为：在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。
//        System.out.println(iterator.next());

        //方式二：不推荐
//        for(int i = 0;i &lt; coll.size();i++){
//            System.out.println(iterator.next());
//        }

        //方式三：推荐
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}</code></pre>
<h2 id="3-2、迭代器Iterator的执行原理"><a href="#3-2、迭代器Iterator的执行原理" class="headerlink" title="3.2、迭代器Iterator的执行原理"></a>3.2、迭代器Iterator的执行原理</h2><p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183527.png" alt=""></p>
<h2 id="3-3、Iterator遍历集合的两种错误写法"><a href="#3-3、Iterator遍历集合的两种错误写法" class="headerlink" title="3.3、Iterator遍历集合的两种错误写法"></a>3.3、Iterator遍历集合的两种错误写法</h2><pre><code class="java">import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

/**
 * 集合元素的遍历操作，使用迭代器Iterator接口
 * 1.内部的方法：hasNext()和 next()
 * 2.集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。
 */
public class IteratorTest {

    @Test
    public void test2(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person(&quot;Jerry&quot;,20));
        coll.add(new String(&quot;Tom&quot;));
        coll.add(false);

        //错误方式一：
//        Iterator iterator = coll.iterator();
//        while(iterator.next() != null){
//            System.out.println(iterator.next());
//        }

        //错误方式二：
        //集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。
        while(coll.iterator().hasNext()){
            System.out.println(coll.iterator().next());
        }
    }
}</code></pre>
<h2 id="3-4、Iterator迭代器remove-的使用"><a href="#3-4、Iterator迭代器remove-的使用" class="headerlink" title="3.4、Iterator迭代器remove()的使用"></a>3.4、Iterator迭代器remove()的使用</h2><pre><code class="java">import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

/**
 * 集合元素的遍历操作，使用迭代器Iterator接口
 * 1.内部的方法：hasNext()和 next()
 * 2.集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。
 * 3.内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()
 */
public class IteratorTest {

    //测试Iterator中的remove()方法
    @Test
    public void test3(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person(&quot;Jerry&quot;,20));
        coll.add(new String(&quot;Tom&quot;));
        coll.add(false);

        //删除集合中”Tom”
        //如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，
        // 再调用remove都会报IllegalStateException。
        Iterator iterator = coll.iterator();
        while(iterator.hasNext()){
//            iterator.remove();
            Object obj = iterator.next();
            if(&quot;Tom&quot;.equals(obj)){
                iterator.remove();
//                iterator.remove();                
            }
        }

        //遍历集合
        iterator = coll.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }

    }
}</code></pre>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li>Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。</li>
<li><strong>如果还未调用next()或在上一次调用next方法之后已经调用了remove方法，再调用remove都会报IllegalStateException</strong>。</li>
</ul>
<h2 id="3-5、新特性foreach循环遍历集合或数组"><a href="#3-5、新特性foreach循环遍历集合或数组" class="headerlink" title="3.5、新特性foreach循环遍历集合或数组"></a>3.5、新特性foreach循环遍历集合或数组</h2><ul>
<li>Java 5.0 提供了foreach循环迭代访问Collection和数组。</li>
<li>遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。</li>
<li>遍历集合的底层调用Iterator完成操作。</li>
<li>foreach还可以用来遍历数组。</li>
</ul>
<p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183535.png" alt=""></p>
<pre><code class="java">import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;

/**
 * jdk 5.0 新增了foreach循环，用于遍历集合、数组
 *
 */
public class ForTest {

    @Test
    public void test(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person(&quot;Jerry&quot;,20));
        coll.add(new String(&quot;Tom&quot;));
        coll.add(false);

        //for(集合元素的类型 局部变量 : 集合对象),内部仍然调用了迭代器。
        for(Object obj : coll){
            System.out.println(obj);
        }
    }

    @Test
    public void test2(){
        int[] arr = new int[]{1,2,3,4,5,6};
        //for(数组元素的类型 局部变量 : 数组对象)
        for(int i : arr){
            System.out.println(i);
        }
    }

    //练习题
    @Test
    public void test3(){
        String[] arr = new String[]{&quot;SS&quot;,&quot;KK&quot;,&quot;RR&quot;};

//        //方式一：普通for赋值
//        for(int i = 0;i &lt; arr.length;i++){
//            arr[i] = &quot;HH&quot;;
//        }

        //方式二：增强for循环
        for(String s : arr){
            s = &quot;HH&quot;;
        }

        for(int i = 0;i &lt; arr.length;i++){
            System.out.println(arr[i]);
        }
    }
}</code></pre>
<h1 id="04、Collection子接口之一：List接口"><a href="#04、Collection子接口之一：List接口" class="headerlink" title="04、Collection子接口之一：List接口"></a>04、Collection子接口之一：List接口</h1><ul>
<li>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</li>
<li>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li>
<li>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。</li>
</ul>
<h2 id="4-1、List接口常用实现类的对比"><a href="#4-1、List接口常用实现类的对比" class="headerlink" title="4.1、List接口常用实现类的对比"></a>4.1、List接口常用实现类的对比</h2><pre><code class="java">/**
 * 1. List接口框架
 *
 *    |----Collection接口：单列集合，用来存储一个一个的对象
 *          |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组,替换原有的数组
 *              |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储
 *              |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储
 *              |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储
 *
 *
 * 面试题：比较ArrayList、LinkedList、Vector三者的异同？
 *        同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据
 *        不同：见上
 *
 */</code></pre>
<h2 id="4-2、ArrayList的源码分析"><a href="#4-2、ArrayList的源码分析" class="headerlink" title="4.2、ArrayList的源码分析"></a>4.2、ArrayList的源码分析</h2><ul>
<li>ArrayList是List 接口的典型实现类、主要实现类</li>
<li>本质上，ArrayList是对象引用的一个”变长”数组</li>
</ul>
<pre><code class="java">/** 
 * 2.ArrayList的源码分析：
 *   2.1 jdk 7情况下
 *      ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData
 *      list.add(123);//elementData[0] = new Integer(123);
 *      ...
 *      list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。
 *      默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。
 *
 *      结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)
 *
 *   2.2 jdk 8中ArrayList的变化：
 *      ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组
 *
 *      list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]
 *      ...
 *      后续的添加和扩容操作与jdk 7 无异。
 *   2.3 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象
 *            的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。
 * 
 */</code></pre>
<h2 id="4-3、LinkedList的源码分析"><a href="#4-3、LinkedList的源码分析" class="headerlink" title="4.3、LinkedList的源码分析"></a>4.3、LinkedList的源码分析</h2><ul>
<li>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高</li>
<li>LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基本结构。</li>
</ul>
<p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183544.png" alt=""></p>
<pre><code class="java">/**
  * 3.LinkedList的源码分析：
  *       LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null
  *       list.add(123);//将123封装到Node中，创建了Node对象。
  *
  *       其中，Node定义为：体现了LinkedList的双向链表的说法
  *       private static class Node&lt;E&gt; {
  *            E item;
  *            Node&lt;E&gt; next;
  *            Node&lt;E&gt; prev;
  *
  *            Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
  *            this.item = element;
  *            this.next = next;     //next变量记录下一个元素的位置
  *            this.prev = prev;     //prev变量记录前一个元素的位置
  *            }
  *        }
  */</code></pre>
<h2 id="4-4、Vector的源码分析"><a href="#4-4、Vector的源码分析" class="headerlink" title="4.4、Vector的源码分析"></a>4.4、Vector的源码分析</h2><ul>
<li>Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。</li>
<li>在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。</li>
</ul>
<pre><code class="java">/** 
  * 4.Vector的源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。
  *      在扩容方面，默认扩容为原来的数组长度的2倍。
  */ </code></pre>
<h2 id="4-5、List接口中的常用方法测试"><a href="#4-5、List接口中的常用方法测试" class="headerlink" title="4.5、List接口中的常用方法测试"></a>4.5、List接口中的常用方法测试</h2><blockquote>
<p>List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。</p>
</blockquote>
<ul>
<li><code>void add(intindex, Object ele)</code>:在index位置插入ele元素</li>
<li><code>boolean addAll(int index, Collection eles)</code>:从index位置开始将eles中的所有元素添加进来</li>
<li><code>Object get(int index)</code>:获取指定index位置的元素</li>
<li><code>int indexOf(Object obj)</code>:返回obj在集合中首次出现的位置</li>
<li><code>int lastIndexOf(Object obj)</code>:返回obj在当前集合中末次出现的位置</li>
<li><code>Object remove(int index)</code>:移除指定index位置的元素，并返回此元素</li>
<li><code>Object set(int index, Object ele)</code>:设置指定index位置的元素为ele</li>
<li><code>List subList(int fromIndex, int toIndex)</code>:返回从fromIndex到toIndex位置的子集合</li>
</ul>
<pre><code class="java">import org.junit.Test;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

/**
 *
 * 5.List接口的常用方法
 */
public class ListTest {
    /**
     *
     * void add(int index, Object ele):在index位置插入ele元素
     * boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来
     * Object get(int index):获取指定index位置的元素
     * int indexOf(Object obj):返回obj在集合中首次出现的位置
     * int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置
     * Object remove(int index):移除指定index位置的元素，并返回此元素
     * Object set(int index, Object ele):设置指定index位置的元素为ele
     * List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合
     *
     * 总结：常用方法
     * 增：add(Object obj)
     * 删：remove(int index) / remove(Object obj)
     * 改：set(int index, Object ele)
     * 查：get(int index)
     * 插：add(int index, Object ele)
     * 长度：size()
     * 遍历：① Iterator迭代器方式
     *      ② 增强for循环
     *      ③ 普通的循环
     *
     */

    @Test
    public void test3(){
        ArrayList list = new ArrayList();
        list.add(123);
        list.add(456);
        list.add(&quot;AA&quot;);

        //方式一：Iterator迭代器方式
        Iterator iterator = list.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }

        System.out.println(&quot;***************&quot;);

        //方式二：增强for循环
        for(Object obj : list){
            System.out.println(obj);
        }

        System.out.println(&quot;***************&quot;);

        //方式三：普通for循环
        for(int i = 0;i &lt; list.size();i++){
            System.out.println(list.get(i));
        }
    }

    @Test
    public void tets2(){
        ArrayList list = new ArrayList();
        list.add(123);
        list.add(456);
        list.add(&quot;AA&quot;);
        list.add(new Person(&quot;Tom&quot;,12));
        list.add(456);
        //int indexOf(Object obj):返回obj在集合中首次出现的位置。如果不存在，返回-1.
        int index = list.indexOf(4567);
        System.out.println(index);

        //int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置。如果不存在，返回-1.
        System.out.println(list.lastIndexOf(456));

        //Object remove(int index):移除指定index位置的元素，并返回此元素
        Object obj = list.remove(0);
        System.out.println(obj);
        System.out.println(list);

        //Object set(int index, Object ele):设置指定index位置的元素为ele
        list.set(1,&quot;CC&quot;);
        System.out.println(list);

        //List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的左闭右开区间的子集合
        List subList = list.subList(2, 4);
        System.out.println(subList);
        System.out.println(list);
    }

    @Test
    public void test(){
        ArrayList list = new ArrayList();
        list.add(123);
        list.add(456);
        list.add(&quot;AA&quot;);
        list.add(new Person(&quot;Tom&quot;,12));
        list.add(456);

        System.out.println(list);

        //void add(int index, Object ele):在index位置插入ele元素
        list.add(1,&quot;BB&quot;);
        System.out.println(list);

        //boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来
        List list1 = Arrays.asList(1, 2, 3);
        list.addAll(list1);
//        list.add(list1);
        System.out.println(list.size());//9

        //Object get(int index):获取指定index位置的元素
        System.out.println(list.get(2));

    }
}</code></pre>
<h2 id="4-6、List的一个面试小题"><a href="#4-6、List的一个面试小题" class="headerlink" title="4.6、List的一个面试小题"></a>4.6、List的一个面试小题</h2><blockquote>
<p>1、面试题1</p>
</blockquote>
<p>请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别?</p>
<pre><code class="java">   /**
     * 请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？
     * ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别?
     * 
     * ArrayList和LinkedList的异同二者都线程不安全，相对线程安全的Vector，执行效率高。
     * 此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。
     * 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。
     * 对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。
     * 
     * ArrayList和Vector的区别Vector和ArrayList几乎是完全相同的,
     * 唯一的区别在于Vector是同步类(synchronized)，属于强同步类。
     * 因此开销就比ArrayList要大，访问要慢。正常情况下,
     * 大多数的Java程序员使用ArrayList而不是Vector,
     * 因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，
     * 而ArrayList是1.5倍。Vector还有一个子类Stack。
     */</code></pre>
<blockquote>
<p>2、面试题2</p>
</blockquote>
<pre><code class="java">import org.junit.Test;

import java.util.ArrayList;
import java.util.List;

public class ListEver {
    /**
     * 区分List中remove(int index)和remove(Object obj)
     */

    @Test
    public void testListRemove() {
        List list = new ArrayList();
        list.add(1);
        list.add(2);
        list.add(3);
        updateList(list);
        System.out.println(list);//
    }

    private void updateList(List list) {
//        list.remove(2);
        list.remove(new Integer(2));
    }
}</code></pre>
<h1 id="05、Collection子接口之二：Set接口"><a href="#05、Collection子接口之二：Set接口" class="headerlink" title="05、Collection子接口之二：Set接口"></a>05、Collection子接口之二：Set接口</h1><ul>
<li>Set接口是Collection的子接口，set接口没有提供额外的方法</li>
<li>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。</li>
<li><strong>Set 判断两个对象是否相同不是使用<code>==</code>运算符，而是根据<code>equals()</code>方法</strong></li>
</ul>
<h2 id="5-1、Set接口实现类的对比"><a href="#5-1、Set接口实现类的对比" class="headerlink" title="5.1、Set接口实现类的对比"></a>5.1、Set接口实现类的对比</h2><pre><code class="java">/**
 * 1.Set接口的框架：
 * |----Collection接口：单列集合，用来存储一个一个的对象
 *          |----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”
 *             |----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值
 *                 |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历
 *                                    对于频繁的遍历操作，LinkedHashSet效率高于HashSet.
 *             |----TreeSet：可以按照添加对象的指定属性，进行排序。
 */</code></pre>
<h2 id="5-2、Set的无序性与不可重复性的理解"><a href="#5-2、Set的无序性与不可重复性的理解" class="headerlink" title="5.2、Set的无序性与不可重复性的理解"></a>5.2、Set的无序性与不可重复性的理解</h2><blockquote>
<p>1、测试类</p>
</blockquote>
<pre><code class="java">import org.junit.Test;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

/**
 *
 * 1.Set接口中没有定义额外的方法，使用的都是Collection中声明过的方法。
 *
 */
public class SetTest {

    /**
     * 一、Set:存储无序的、不可重复的数据
     *      1.无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。
     *
     *      2.不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。
     *
     * 二、添加元素的过程：以HashSet为例：
     *
     *
     */
    @Test
    public void test(){
        Set set = new HashSet();
        set.add(123);
        set.add(456);
        set.add(&quot;fgd&quot;);
        set.add(&quot;book&quot;);
        set.add(new User(&quot;Tom&quot;,12));
        set.add(new User(&quot;Tom&quot;,12));
        set.add(129);

        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}</code></pre>
<blockquote>
<p>2、User类</p>
</blockquote>
<pre><code class="java">public class User{
    private String name;
    private int age;

    public User() {
    }

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;}&#39;;
    }

    @Override
    public boolean equals(Object o) {
        System.out.println(&quot;User equals()....&quot;);
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        User user = (User) o;

        if (age != user.age) return false;
        return name != null ? name.equals(user.name) : user.name == null;
    }

    @Override
    public int hashCode() { 
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }
}</code></pre>
<h2 id="5-3、HashSet中元素的添加过程"><a href="#5-3、HashSet中元素的添加过程" class="headerlink" title="5.3、HashSet中元素的添加过程"></a>5.3、HashSet中元素的添加过程</h2><ul>
<li><code>HashSet</code>是<code>Set</code> 接口的典型实现，大多数时候使用Set 集合时都使用这个实现类。</li>
<li><code>HashSe</code>t按<code>Hash</code> 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。</li>
<li><code>HashSet</code>具有以下特点：不能保证元素的排列顺序<ul>
<li><strong><code>HashSet</code>不是线程安全的</strong></li>
<li><strong>集合元素可以是<code>null</code></strong></li>
</ul>
</li>
<li><strong>底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75=12）就会扩大容量为原来的2倍。（16扩容为32，依次为64,128…等）</strong></li>
<li><strong><code>HashSet</code> 集合判断两个元素相等的标准：两个对象通过<code>hashCode()</code> 方法比较相等，并且两个对象的<code>equals()</code>方法返回值也相等。</strong></li>
<li>对于存放在<code>Set</code>容器中的对象，对应的类一定要重写<code>equals()</code>和<code>hashCode(Object obj)</code>方法，以实现对象相等规则。即：“<strong>相等的对象必须具有相等的散列码</strong>”。</li>
</ul>
<pre><code class="java">/**
     * 一、Set:存储无序的、不可重复的数据
     *      1.无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。
     *
     *      2.不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。
     *
     * 二、添加元素的过程：以HashSet为例：
     *      我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，
     *      此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断
     *      数组此位置上是否已经有元素：
     *          如果此位置上没有其他元素，则元素a添加成功。 ---&gt;情况1
     *          如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：
     *              如果hash值不相同，则元素a添加成功。---&gt;情况2
     *              如果hash值相同，进而需要调用元素a所在类的equals()方法：
     *                    equals()返回true,元素a添加失败
     *                    equals()返回false,则元素a添加成功。---&gt;情况2
     *
     *      对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。
     *      jdk 7 :元素a放到数组中，指向原来的元素。
     *      jdk 8 :原来的元素在数组中，指向元素a
     *      总结：七上八下
     *
     * HashSet底层：数组+链表的结构。
     *
     */</code></pre>
<p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183606.png" alt=""></p>
<h2 id="5-4、关于hashCode-和equals-的重写"><a href="#5-4、关于hashCode-和equals-的重写" class="headerlink" title="5.4、关于hashCode()和equals()的重写"></a>5.4、关于hashCode()和equals()的重写</h2><h3 id="5-4-1、重写hashCode-方法的基本原则"><a href="#5-4-1、重写hashCode-方法的基本原则" class="headerlink" title="5.4.1、重写hashCode() 方法的基本原则"></a>5.4.1、重写hashCode() 方法的基本原则</h3><ul>
<li>在程序运行时，同一个对象多次调用<code>hashCode()</code>方法应该返回相同的值。</li>
<li>当两个对象的<code>equals()</code>方法比较返回<code>true</code>时，这两个对象的<code>hashCode()</code>方法的返回值也应相等。</li>
<li>对象中用作<code>equals()</code> 方法比较的<code>Field</code>，都应该用来计算<code>hashCode</code>值。</li>
</ul>
<h3 id="5-4-2、重写equals-方法的基本原则"><a href="#5-4-2、重写equals-方法的基本原则" class="headerlink" title="5.4.2、重写equals() 方法的基本原则"></a>5.4.2、重写equals() 方法的基本原则</h3><blockquote>
<p>以自定义的Customer类为例，何时需要重写equals()？</p>
</blockquote>
<ul>
<li>当一个类有自己特有的“逻辑相等”概念,当改写equals()的时候，总是要改写<code>hashCode()</code>，根据一个类的<code>equals</code>方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据<code>Object.hashCode()</code>方法，它们仅仅是两个对象。</li>
<li>因此，违反了“<strong>相等的对象必须具有相等的散列码</strong>”。</li>
<li>结论：复写<code>equals</code>方法的时候一般都需要同时复写<code>hashCode</code>方法。通常参与计算<code>hashCod</code>e的对象的属性也应该参与到<code>equals()</code>中进行计算。</li>
</ul>
<h3 id="5-4-3、Eclipse-IDEA工具里hashCode-的重写"><a href="#5-4-3、Eclipse-IDEA工具里hashCode-的重写" class="headerlink" title="5.4.3、Eclipse/IDEA工具里hashCode()的重写"></a>5.4.3、Eclipse/IDEA工具里hashCode()的重写</h3><blockquote>
<p>以Eclipse/IDEA为例，在自定义类中可以调用工具自动重写equals和hashCode。问题：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？</p>
</blockquote>
<ul>
<li>选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）</li>
<li>并且31只占用5bits,相乘造成数据溢出的概率较小。</li>
<li>31可以由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）</li>
<li>31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突)</li>
</ul>
<pre><code class="java">/**
  * 2.要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()
  *   要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码
  *        重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。
 */</code></pre>
<h2 id="5-5、LinkedHashSet的使用"><a href="#5-5、LinkedHashSet的使用" class="headerlink" title="5.5、LinkedHashSet的使用"></a>5.5、LinkedHashSet的使用</h2><ul>
<li><code>LinkedHashSet</code>是<code>HashSet</code>的子类</li>
<li><code>LinkedHashSet</code>根据元素的<code>hashCode</code>值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以<strong>插入顺序保存</strong>的。</li>
<li><strong><code>LinkedHashSet</code>插入性能略低于<code>HashSet</code></strong>，但在迭代访问Set 里的全部元素时有很好的性能。</li>
<li>LinkedHashSet不允许集合元素重复。</li>
</ul>
<p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183620.png" alt=""></p>
<blockquote>
<p>1、测试类</p>
</blockquote>
<pre><code class="java">import org.junit.Test;

import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Set;

public class SetTest {

    /**
     * LinkedHashSet的使用
     * LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个
     * 数据和后一个数据。
     * 优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet
     */
    @Test
    public void test2(){
        Set set = new LinkedHashSet();
        set.add(456);
        set.add(123);
        set.add(123);
        set.add(&quot;AA&quot;);
        set.add(&quot;CC&quot;);
        set.add(new User(&quot;Tom&quot;,12));
        set.add(new User(&quot;Tom&quot;,12));
        set.add(129);

        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}</code></pre>
<blockquote>
<p>2、User类</p>
</blockquote>
<pre><code class="java">public class User{
    private String name;
    private int age;

    public User() {
    }

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;}&#39;;
    }

    @Override
    public boolean equals(Object o) {
        System.out.println(&quot;User equals()....&quot;);
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        User user = (User) o;

        if (age != user.age) return false;
        return name != null ? name.equals(user.name) : user.name == null;
    }

    @Override
    public int hashCode() { //return name.hashCode() + age;
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }
}</code></pre>
<h2 id="5-6、TreeSet的自然排序"><a href="#5-6、TreeSet的自然排序" class="headerlink" title="5.6、TreeSet的自然排序"></a>5.6、TreeSet的自然排序</h2><ul>
<li><code>TreeSet</code>是<code>SortedSet</code>接口的实现类，<code>TreeSet</code>可以确保集合元素处于排序状态。</li>
<li><code>TreeSet</code>底层使用<strong>红黑树</strong>结构存储数据</li>
<li>新增的方法如下：(了解)<ul>
<li><code>Comparator comparator()</code></li>
<li><code>Object first()</code></li>
<li><code>Object last()</code></li>
<li><code>Object lower(Object e)</code></li>
<li><code>Object higher(Object e)</code></li>
<li><code>SortedSet subSet(fromElement, toElement)</code></li>
<li><code>SortedSet headSet(toElement)</code></li>
<li><code>SortedSet tailSet(fromElement)</code></li>
</ul>
</li>
<li><code>TreeSet</code>两种排序方法：<strong>自然排序和定制排序</strong>。默认情况下，<code>TreeSet</code>采用自然排序。</li>
<li><code>TreeSet</code>和后面要讲的<code>TreeMap</code>采用红黑树的存储结构</li>
<li>特点：有序，查询速度比<code>List</code>快</li>
<li><strong>自然排序</strong>：<code>TreeSet</code>会调用集合元素的<code>compareTo(Object obj)</code>方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列。</li>
<li><strong>如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable 接口</strong>。<ul>
<li>实现<code>Comparable</code> 的类必须实现<code>compareTo(Object obj)</code>方法，两个对象即通过<code>compareTo(Object obj)</code>方法的返回值来比较大小。</li>
</ul>
</li>
<li><code>Comparable</code> 的典型实现：<ul>
<li><code>BigDecimal、BigInteger</code>以及所有的数值型对应的包装类：按它们对应的数值大小进行比较</li>
<li><code>Character</code>：按字符的unicode值来进行比较</li>
<li><code>Boolean</code>：true 对应的包装类实例大于false 对应的包装类实例</li>
<li><code>String</code>：按字符串中字符的unicode 值进行比较</li>
<li><code>Date、Time</code>：后边的时间、日期比前面的时间、日期大</li>
</ul>
</li>
<li><code>向TreeSet</code>中添加元素时，只有第一个元素无须比较<code>compareTo()</code>方法，后面添加的所有元素都会调用<code>compareTo()</code>方法进行比较。</li>
<li><strong>因为只有相同类的两个实例才会比较大小，所以向<code>TreeSet</code>中添加的应该是同一个类的对象</strong>。</li>
<li>对于<code>TreeSet</code>集合而言，它<strong>判断两个对象是否相等的唯一标准</strong>是：两个对象通过<code>compareTo(Object obj)</code>方法比较返回值。</li>
<li>当需要把一个对象放入<code>TreeSet</code>中，重写该对象对应的<code>equals()</code>方法时，应保证该方法与<code>compareTo(Object obj)</code> 方法有一致的结果：如果两个对象通过<code>equals()</code>方法比较返回true，则通过<code>compareTo(Object obj)</code>方法比较应返回0。否则，让人难以理解。</li>
</ul>
<blockquote>
<p>红黑树</p>
</blockquote>
<p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183628.png" alt=""></p>
<blockquote>
<p>1、测试类</p>
</blockquote>
<pre><code class="java">import org.junit.Test;

import java.util.Iterator;
import java.util.TreeSet;

/**
 * 1.向TreeSet中添加的数据，要求是相同类的对象。
 * 2.两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator）
 * 3.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().
 * 4.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().
 */
public class TreeSetTest {

    @Test
    public void test() {
        TreeSet set = new TreeSet();

        //失败：不能添加不同类的对象
//        set.add(123);
//        set.add(456);
//        set.add(&quot;AA&quot;);
//        set.add(new User(&quot;Tom&quot;,12));

        //举例一：
//        set.add(34);
//        set.add(-34);
//        set.add(43);
//        set.add(11);
//        set.add(8);

        //举例二：
        set.add(new User(&quot;Tom&quot;,12));
        set.add(new User(&quot;Jerry&quot;,32));
        set.add(new User(&quot;Jim&quot;,2));
        set.add(new User(&quot;Mike&quot;,65));
        set.add(new User(&quot;Jack&quot;,33));
        set.add(new User(&quot;Jack&quot;,56));

        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}</code></pre>
<blockquote>
<p>2、User类</p>
</blockquote>
<pre><code class="java">public class User implements Comparable{
    private String name;
    private int age;

    public User() {
    }

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;}&#39;;
    }

    @Override
    public boolean equals(Object o) {
        System.out.println(&quot;User equals()....&quot;);
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        User user = (User) o;

        if (age != user.age) return false;
        return name != null ? name.equals(user.name) : user.name == null;
    }

    @Override
    public int hashCode() { //return name.hashCode() + age;
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }

    //按照姓名从大到小排列,年龄从小到大排列
    @Override
    public int compareTo(Object o) {
        if (o instanceof User) {
            User user = (User) o;
//            return this.name.compareTo(user.name);  //按照姓名从小到大排列
//            return -this.name.compareTo(user.name);  //按照姓名从大到小排列
            int compare = -this.name.compareTo(user.name);  //按照姓名从大到小排列
            if(compare != 0){   //年龄从小到大排列
                return compare;
            }else{
                return Integer.compare(this.age,user.age);
            }
        } else {
            throw new RuntimeException(&quot;输入的类型不匹配&quot;);
        }
    }
}</code></pre>
<h2 id="5-7、TreeSet的定制排序"><a href="#5-7、TreeSet的定制排序" class="headerlink" title="5.7、TreeSet的定制排序"></a>5.7、TreeSet的定制排序</h2><ul>
<li><code>TreeSet</code>的<strong>自然排序</strong>要求元素所属的类实现<code>Comparable</code>接口，如果元素所属的类没有实现<code>Comparable</code>接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过<code>Comparator</code>接口来实现。需要重写<code>compare(T o1,T o2</code>)方法。</li>
<li>利用<code>int compare(T o1,T o2)</code>方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</li>
<li>要实现<strong>定制排序</strong>，需要将实现<code>Comparator</code>接口的实例作为形参传递给<code>TreeSe</code>t的构造器。</li>
<li>此时，仍然只能向<code>TreeSet</code>中添加类型相同的对象。否则发生<code>ClassCastException</code>异常。</li>
<li>使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。</li>
</ul>
<blockquote>
<p>1、测试类</p>
</blockquote>
<pre><code class="java">import org.junit.Test;

import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;

/**
 * 1.向TreeSet中添加的数据，要求是相同类的对象。
 * 2.两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator）
 * 3.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().
 * 4.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().
 */
public class TreeSetTest {

    @Test
    public void tets2(){
        Comparator com = new Comparator() {
            //按照年龄从小到大排列
            @Override
            public int compare(Object o1, Object o2) {
                if(o1 instanceof User &amp;&amp; o2 instanceof User){
                    User u1 = (User)o1;
                    User u2 = (User)o2;
                    return Integer.compare(u1.getAge(),u2.getAge());
                }else{
                    throw new RuntimeException(&quot;输入的数据类型不匹配&quot;);
                }
            }
        };

        TreeSet set = new TreeSet(com);
        set.add(new User(&quot;Tom&quot;,12));
        set.add(new User(&quot;Jerry&quot;,32));
        set.add(new User(&quot;Jim&quot;,2));
        set.add(new User(&quot;Mike&quot;,65));
        set.add(new User(&quot;Mary&quot;,33));
        set.add(new User(&quot;Jack&quot;,33));
        set.add(new User(&quot;Jack&quot;,56));


        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}</code></pre>
<blockquote>
<p>2、User类</p>
</blockquote>
<pre><code class="java">public class User implements Comparable{
    private String name;
    private int age;

    public User() {
    }

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;}&#39;;
    }

    @Override
    public boolean equals(Object o) {
        System.out.println(&quot;User equals()....&quot;);
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        User user = (User) o;

        if (age != user.age) return false;
        return name != null ? name.equals(user.name) : user.name == null;
    }

    @Override
    public int hashCode() { //return name.hashCode() + age;
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }

    //按照姓名从大到小排列,年龄从小到大排列
    @Override
    public int compareTo(Object o) {
        if (o instanceof User) {
            User user = (User) o;
//            return this.name.compareTo(user.name);  //按照姓名从小到大排列
//            return -this.name.compareTo(user.name);  //按照姓名从大到小排列
            int compare = -this.name.compareTo(user.name);  //按照姓名从大到小排列
            if(compare != 0){   //年龄从小到大排列
                return compare;
            }else{
                return Integer.compare(this.age,user.age);
            }
        } else {
            throw new RuntimeException(&quot;输入的类型不匹配&quot;);
        }
    }
}</code></pre>
<h2 id="5-8、TreeSet的课后练习"><a href="#5-8、TreeSet的课后练习" class="headerlink" title="5.8、TreeSet的课后练习"></a>5.8、TreeSet的课后练习</h2><p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183640.png" alt=""></p>
<blockquote>
<p>1、MyDate类</p>
</blockquote>
<pre><code class="java">/**
 * MyDate类包含:
 * private成员变量year,month,day；并为每一个属性定义getter,  setter 方法；
 */
public class MyDate implements Comparable{
    private int year;
    private int month;
    private int day;

    public int getYear() {
        return year;
    }

    public void setYear(int year) {
        this.year = year;
    }

    public int getMonth() {
        return month;
    }

    public void setMonth(int month) {
        this.month = month;
    }

    public int getDay() {
        return day;
    }

    public void setDay(int day) {
        this.day = day;
    }

    public MyDate() {
    }

    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    @Override
    public String toString() {
        return &quot;MyDate{&quot; +
                &quot;year=&quot; + year +
                &quot;, month=&quot; + month +
                &quot;, day=&quot; + day +
                &#39;}&#39;;
    }

    @Override
    public int compareTo(Object o) {
        if(o instanceof MyDate){
            MyDate m = (MyDate)o;

            //比较年
            int minusYear = this.getYear() - m.getYear();
            if(minusYear != 0){
                return minusYear;
            }
            //比较月
            int minusMonth = this.getMonth() - m.getMonth();
            if(minusMonth != 0){
                return minusMonth;
            }
            //比较日
            return this.getDay() - m.getDay();
        }

        throw new RuntimeException(&quot;传入的数据类型不一致！&quot;);

    }
}</code></pre>
<blockquote>
<p>2、Employee类</p>
</blockquote>
<pre><code class="java">/**
 * 定义一个Employee类。
 * 该类包含：private成员变量name,age,birthday，
 * 其中birthday 为MyDate 类的对象；
 * 并为每一个属性定义getter, setter 方法；
 * 并重写toString 方法输出name, age, birthday
 */
public class Employee implements Comparable{
    private String name;
    private int age;
    private MyDate birthday;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public MyDate getBirthday() {
        return birthday;
    }

    public void setBirthday(MyDate birthday) {
        this.birthday = birthday;
    }

    public Employee() {
    }

    public Employee(String name, int age, MyDate birthday) {
        this.name = name;
        this.age = age;
        this.birthday = birthday;
    }

    @Override
    public String toString() {
        return &quot;Employee{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, birthday=&quot; + birthday +
                &#39;}&#39;;
    }

    //按name排序
    @Override
    public int compareTo(Object o){
        if(o instanceof Employee){
            Employee e = (Employee)o;
            return this.name.compareTo(e.name);
        }
//        return 0;
        throw new RuntimeException(&quot;传入的数据类型不一致&quot;);
    }
}</code></pre>
<blockquote>
<p>3、测试类</p>
</blockquote>
<pre><code class="java">import org.junit.Test;

import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;

/**
 * 创建该类的5 个对象，并把这些对象放入TreeSet 集合中
 * （下一章：TreeSet 需使用泛型来定义）分别按以下两种方式
 * 对集合中的元素进行排序，并遍历输出：
 *
 * 1). 使Employee 实现Comparable 接口，并按name 排序
 * 2). 创建TreeSet 时传入Comparator对象，按生日日期的先后排序。
 */
public class EmployeeTest {

    //问题二：按生日日期的先后排序
    @Test
    public void test2(){
        TreeSet set = new TreeSet(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                if(o1 instanceof Employee &amp;&amp; o2 instanceof Employee){
                    Employee e1 = (Employee)o1;
                    Employee e2 = (Employee)o2;

                    MyDate b1 = e1.getBirthday();
                    MyDate b2 = e2.getBirthday();

                    //方式一：
//                    //比较年
//                    int minusYear = b1.getYear() - b2.getYear();
//                    if(minusYear != 0){
//                        return minusYear;
//                    }
//
//                    //比较月
//                    int minusMonth = b1.getMonth() - b2.getMonth();
//                    if(minusMonth != 0){
//                        return minusMonth;
//                    }
//
//                    //比较日
//                    return b1.getDay() - b2.getDay();

                    //方式二：
                    return b1.compareTo(b2);
                }
//                return 0;
                throw new RuntimeException(&quot;传入的数据类型不一致！&quot;);
            }
        });

        Employee e1 = new Employee(&quot;wangxianzhi&quot;,41,new MyDate(334,5,4));
        Employee e2 = new Employee(&quot;simaqian&quot;,43,new MyDate(-145,7,12));
        Employee e3 = new Employee(&quot;yanzhenqin&quot;,44,new MyDate(709,5,9));
        Employee e4 = new Employee(&quot;zhangqian&quot;,51,new MyDate(-179,8,12));
        Employee e5 = new Employee(&quot;quyuan&quot;,21,new MyDate(-340,12,4));

        set.add(e1);
        set.add(e2);
        set.add(e3);
        set.add(e4);
        set.add(e5);

        Iterator iterator = set.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }

    //问题一：使用自然排序
    @Test
    public void test(){
        TreeSet set = new TreeSet();

        Employee e1 = new Employee(&quot;wangxianzhi&quot;,41,new MyDate(334,5,4));
        Employee e2 = new Employee(&quot;simaqian&quot;,43,new MyDate(-145,7,12));
        Employee e3 = new Employee(&quot;yanzhenqin&quot;,44,new MyDate(709,5,9));
        Employee e4 = new Employee(&quot;zhangqian&quot;,51,new MyDate(-179,8,12));
        Employee e5 = new Employee(&quot;quyuan&quot;,21,new MyDate(-340,12,4));

        set.add(e1);
        set.add(e2);
        set.add(e3);
        set.add(e4);
        set.add(e5);

        Iterator iterator = set.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}</code></pre>
<h2 id="5-9、Set课后两道面试题"><a href="#5-9、Set课后两道面试题" class="headerlink" title="5.9、Set课后两道面试题"></a>5.9、Set课后两道面试题</h2><blockquote>
<p>练习：在List内去除重复数字值，要求尽量简单</p>
</blockquote>
<pre><code class="java">import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;

public class CollectionTest {

    //练习：在List内去除重复数字值，要求尽量简单
    public static List duplicateList(List list) {
        HashSet set = new HashSet();
        set.addAll(list);
        return new ArrayList(set);
    }
    @Test
    public void test2(){
        List list = new ArrayList();
        list.add(new Integer(1));
        list.add(new Integer(2));
        list.add(new Integer(2));
        list.add(new Integer(4));
        list.add(new Integer(4));
        List list2 = duplicateList(list);
        for (Object integer : list2) {
            System.out.println(integer);
        }
    }
}</code></pre>
<blockquote>
<p>2、面试题</p>
</blockquote>
<pre><code class="java">import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;

public class CollectionTest {

    @Test
    public void test3(){
        HashSet set = new HashSet();
        Person p1 = new Person(1001,&quot;AA&quot;);
        Person p2 = new Person(1002,&quot;BB&quot;);

        set.add(p1);
        set.add(p2);
        System.out.println(set);

        p1.name = &quot;CC&quot;;
        set.remove(p1);
        System.out.println(set);
        set.add(new Person(1001,&quot;CC&quot;));
        System.out.println(set);
        set.add(new Person(1001,&quot;AA&quot;));
        System.out.println(set);

    }
}</code></pre>
<blockquote>
<p>Person类</p>
</blockquote>
<pre><code class="java">public class Person {

    int id;
    String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public Person() {

    }

    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Person person = (Person) o;

        if (id != person.id) return false;
        return name != null ? name.equals(person.name) : person.name == null;
    }

    @Override
    public int hashCode() {
        int result = id;
        result = 31 * result + (name != null ? name.hashCode() : 0);
        return result;
    }
}</code></pre>
<h1 id="06、Map接口"><a href="#06、Map接口" class="headerlink" title="06、Map接口"></a>06、Map接口</h1><p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183654.png" alt=""></p>
<h2 id="6-1、Map接口及其多个实现类的对比"><a href="#6-1、Map接口及其多个实现类的对比" class="headerlink" title="6.1、Map接口及其多个实现类的对比"></a>6.1、Map接口及其多个实现类的对比</h2><pre><code class="java">import org.junit.Test;

import java.util.HashMap;
import java.util.Map;

/**
 * 一、Map的实现类的结构：
 *  |----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)
 *         |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value
 *              |----LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。
 *                      原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。
 *                      对于频繁的遍历操作，此类执行效率高于HashMap。
 *         |----TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序
 *                      底层使用红黑树
 *         |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value
 *              |----Properties:常用来处理配置文件。key和value都是String类型
 *
 *
 *      HashMap的底层：数组+链表  （jdk7及之前）
 *                    数组+链表+红黑树 （jdk 8）
 *
 *  面试题：
 *  1. HashMap的底层实现原理？
 *  2. HashMap 和 Hashtable的异同？
 *  3. CurrentHashMap 与 Hashtable的异同？（暂时不讲）
 *
 */
public class MapTest {
    @Test
    public void test(){
        Map map = new HashMap();
//        map = new Hashtable();
        map.put(null,123);
    }
}</code></pre>
<h2 id="6-2、Map中存储的key-value的特点"><a href="#6-2、Map中存储的key-value的特点" class="headerlink" title="6.2、Map中存储的key-value的特点"></a>6.2、Map中存储的key-value的特点</h2><ul>
<li><code>Map</code>与<code>Collection</code>并列存在。用于保存具有映射关系的数据:<code>key-value</code></li>
<li><code>Map</code>中的<code>key</code>和<code>value</code>都可以是任何引用类型的数据</li>
<li><code>Map</code> 中的<code>key</code> 用<code>Set</code>来存放，不允许重复，即同一个<code>Map</code> 对象所对应的类，须重写<code>hashCode()</code>和<code>equals()</code>方法</li>
<li>常用<code>String</code>类作为<code>Ma</code>p的“键”</li>
<li><code>key</code>和<code>value</code>之间存在单向一对一关系，即通过指定的<code>key</code>总能找到唯一的、确定的<code>value</code></li>
<li><code>Map</code>接口的常用实现类：<code>HashMap、TreeMap、LinkedHashMap</code>和<code>Properties</code>。其中，<code>HashMap</code>是<code>Map</code>接口使用频率最高的实现类</li>
</ul>
<p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183705.png" alt=""></p>
<pre><code class="java"> /**
   *  二、Map结构的理解：
   *    Map中的key:无序的、不可重复的，使用Set存储所有的key  ---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例）
   *    Map中的value:无序的、可重复的，使用Collection存储所有的value ---&gt;value所在的类要重写equals()
   *    一个键值对：key-value构成了一个Entry对象。
   *    Map中的entry:无序的、不可重复的，使用Set存储所有的entry
   *
   */   </code></pre>
<h2 id="6-3、Map实现类之一：HashMap"><a href="#6-3、Map实现类之一：HashMap" class="headerlink" title="6.3、Map实现类之一：HashMap"></a>6.3、Map实现类之一：HashMap</h2><ul>
<li><strong><code>HashMap</code>是<code>Map</code>接口使用频率最高的实现类</strong>。</li>
<li>允许使用<code>null</code>键和<code>null</code>值，与<code>HashSet</code>一样，不保证映射的顺序。</li>
<li>所有的<code>key</code>构成的集合是<code>Set</code>:无序的、不可重复的。所以，<code>key</code>所在的类要重写：<code>equals()</code>和<code>hashCode()</code></li>
<li>所有的<code>value</code>构成的集合是<code>Collection</code>:无序的、可以重复的。所以，<code>value</code>所在的类要重写：<code>equals()</code></li>
<li>一个<code>key-value</code>构成一个<code>entry</code></li>
<li>所有的<code>entry</code>构成的集合是<code>Set</code>:无序的、不可重复的</li>
<li><code>HashMap</code>判断两个<code>key</code>相等的标准是：两个<code>key</code>通过<code>equals()</code>方法返回<code>true</code>，<code>hashCode</code>值也相等。</li>
<li><code>HashMap</code>判断两个<code>value</code>相等的标准是：两个<code>value</code> 通过<code>equals()</code>方法返回<code>true</code>。</li>
</ul>
<h2 id="6-4、HashMap的底层实现原理"><a href="#6-4、HashMap的底层实现原理" class="headerlink" title="6.4、HashMap的底层实现原理"></a>6.4、HashMap的底层实现原理</h2><blockquote>
<p><strong>JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法)</strong></p>
<p><strong>JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。</strong></p>
</blockquote>
<p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183714.png" alt=""><br><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183728.png" alt=""></p>
<blockquote>
<p>HashMap源码中的重要常量</p>
</blockquote>
<pre><code class="java">/*
 *      DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16
 *      DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75
 *      threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12
 *      TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8
 *      MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64
*/</code></pre>
<h3 id="6-4-1、HashMap在JDK7中的底层实现原理"><a href="#6-4-1、HashMap在JDK7中的底层实现原理" class="headerlink" title="6.4.1、HashMap在JDK7中的底层实现原理"></a>6.4.1、HashMap在JDK7中的底层实现原理</h3><ul>
<li><code>HashMap的</code>内部存储结构其实是<strong>数组和链表的结合</strong>。当实例化一个<code>HashMap</code>时，系统会创建一个长度为<code>Capacity</code>的<code>Entry</code>数组，这个长度在哈希表中被称为容量(<code>Capacity</code>)，在这个数组中可以存放元素的位置我们称之为“桶”(<code>bucket</code>)，每个<code>bucket</code>都有自己的索引，系统可以根据索引快速的查找<code>bucket</code>中的元素。</li>
<li>每个<code>bucket</code>中存储一个元素，即一个<code>Entry</code>对象，但每一个<code>Entry</code>对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个<code>Entry</code>链。而且新添加的元素作为链表的<code>head</code>。</li>
<li>添加元素的过程：<ul>
<li>向<code>HashMap</code>中添加<code>entry1(key，value)</code>，需要首先计算<code>entry1</code>中<code>key</code>的哈希值(根据<code>key</code>所在类的<code>hashCode()</code>计算得到)，此哈希值经过处理以后，得到在底层<code>Entry[]</code>数组中要存储的位置<code>i</code>。</li>
<li>如果位置<code>i</code>上没有元素，则<code>entry1</code>直接添加成功。</li>
<li>如果位置<code>i</code>上已经存在<code>entry2</code>(或还有链表存在的<code>entry3，entry4</code>)，则需要通过循环的方法，依次比较<code>entry1</code>中<code>key</code>的<code>hash</code>值和其他的<code>entry</code>的<code>hash</code>值。</li>
<li>如果彼此<code>hash</code>值不同，则直接添加成功。</li>
<li>如果<code>hash</code>值相同，继续比较二者是否<code>equals</code>。如果返回值为<code>true</code>，则使用<code>entry1</code>的<code>value</code>去替换<code>equals</code>为<code>true</code>的<code>entry</code>的<code>value</code>。</li>
<li>如果遍历一遍以后，发现所有的<code>equals</code>返回都为<code>false</code>,则<code>entry1</code>仍可添加成功。<code>entry1</code>指向原有的<code>entry</code>元素。</li>
</ul>
</li>
</ul>
<pre><code class="java">/*
 * 三、HashMap的底层实现原理？以jdk7为例说明：
 *    HashMap map = new HashMap():
 *    在实例化以后，底层创建了长度是16的一维数组Entry[] table。
 *    ...可能已经执行过多次put...
 *    map.put(key1,value1):
 *    首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。
 *    如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1
 *    如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据
 *    的哈希值：
 *           如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2
 *           如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：
 *                如果equals()返回false:此时key1-value1添加成功。----情况3
 *                如果equals()返回true:使用value1替换value2。
 *
 *   补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。
 *
 *   在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。
 *
 */

/**
  * HashMap的扩容
  *     当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，
  *     因为数组的长度是固定的。所以为了提高查询的效率，
  *     就要对HashMap的数组进行扩容，而在HashMap数组扩容之后，
  *     最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，
  *     并放进去，这就是resize。
  *     
  * 那么HashMap什么时候进行扩容呢？
  *      当HashMap中的元素个数超过数组大小(数组总大小length,
  *      不是数组中个数size)*loadFactor时，就 会 进 行 数 组 扩 容，
  *      loadFactor的默认值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。
  *      也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，
  *      那么当HashMap中元素个数超过16*0.75=12（这个值就是代码中的threshold值，
  *      也叫做临界值）的时候，就把数组的大小扩展为2*16=32，即扩大一倍，
  *      然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，
  *      所以如果我们已经预知HashMap中元素的个数，
  *      那么预设元素的个数能够有效的提高HashMap的性能。
  */
</code></pre>
<h3 id="6-4-2、HashMap在JDK8中的底层实现原理"><a href="#6-4-2、HashMap在JDK8中的底层实现原理" class="headerlink" title="6.4.2、HashMap在JDK8中的底层实现原理"></a>6.4.2、HashMap在JDK8中的底层实现原理</h3><ul>
<li><p><code>HashMap</code>的内部存储结构其实是<strong>数组+链表+红黑树</strong>的结合。当实例化一个<code>HashMap</code>时，会初始化<code>initialCapacity</code>和<code>loadFactor</code>，在<code>put</code>第一对映射关系时，系统会创建一个长度为<code>initialCapacity</code>的<code>Node</code>数组，这个长度在哈希表中被称为容量(<code>Capacity</code>)，在这个数组中可以存放元素的位置我们称之为“桶”(<code>bucket</code>)，每个<code>bucket</code>都有自己的索引，系统可以根据索引快速的查找<code>bucket</code>中的元素</p>
</li>
<li><p>每个<code>bucket</code>中存储一个元素，即一个<code>Node</code>对象，但每一个<code>Node</code>对象可以带一个引用变量<code>next</code>，用于指向下一个元素，因此，在一个桶中，就有可能生成一个<code>Node</code>链。也可能是一个一个<code>TreeNode</code>对象，每一个<code>TreeNode</code>对象可以有两个叶子结点<code>left</code>和<code>right</code>，因此，在一个桶中，就有可能生成一个<code>TreeNode</code>树。而新添加的元素作为链表的<code>last</code>，或树的叶子结点。</p>
</li>
<li><p><strong>那么HashMap什么时候进行扩容和树形化呢？</strong></p>
<p>当<code>HashMap</code>中的元素个数超过<code>数组大小(数组总大小length,不是数组中个数size)*loadFactor</code>时，就会进行数组扩容，<code>loadFactor</code>的默认值(DEFAULT_LOAD_FACTOR)为<code>0.75</code>，这是一个折中的取值。也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数超过<code>16*0.75=12</code>（这个值就是代码中的t<code>hreshold</code>值，也叫做临界值）的时候，就把数组的大小扩展为<code>2*16=32</code>，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知<code>HashMap</code>中元素的个数，那么预设元素的个数能够有效的提高<code>HashMap</code>的性能。</p>
</li>
<li><p>当<code>HashMap</code>中的其中一个链的对象个数如果达到了<code>8</code>个，此时如果<code>capacity</code>没有达到<code>64</code>，那么<code>HashMap</code>会先扩容解决，如果已经达到了<code>64</code>，那么这个链会变成红黑树，结点类型由<code>Node</code>变成<code>TreeNode</code>类型。当然，如果当映射关系被移除后，下次<code>resize</code>方法时判断树的结点个数低于<code>6</code>个，也会把红黑树再转为链表。</p>
</li>
<li><p><strong>关于映射关系的<code>key</code>是否可以修改？answer：不要修改</strong></p>
<p>映射关系存储到<code>HashMap</code>中会存储<code>key</code>的<code>hash</code>值，这样就不用在每次查找时重新计算每一个<code>Entry</code>或<code>Node（TreeNode）</code>的<code>hash</code>值了，因此如果已经<code>put</code>到<code>Map</code>中的映射关系，再修改<code>key</code>的属性，而这个属性又参与<code>hashcode</code>值的计算，那么会导致匹配不上。</p>
</li>
</ul>
<pre><code class="java">/* 总结：
 *   jdk8 相较于jdk7在底层实现方面的不同：
 *      1.new HashMap():底层没有创建一个长度为16的数组
 *      2.jdk 8底层的数组是：Node[],而非Entry[]
 *      3.首次调用put()方法时，底层创建长度为16的数组
 *      4.jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。
 *         4.1形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）
 *         4.2当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。
 */</code></pre>
<h2 id="6-7、LinkedHashMap的底层实现原理（了解）"><a href="#6-7、LinkedHashMap的底层实现原理（了解）" class="headerlink" title="6.7、LinkedHashMap的底层实现原理（了解）"></a>6.7、LinkedHashMap的底层实现原理（了解）</h2><ul>
<li><p><code>LinkedHashMap</code>是<code>HashMap</code>的子类</p>
</li>
<li><p>在<code>HashMap</code>存储结构的基础上，使用了一对双向链表来记录添加元素的顺序</p>
</li>
<li><p>与<code>LinkedHashSet</code>类似，<code>LinkedHashMap</code>可以维护<code>Map</code> 的迭代顺序：迭代顺序与<code>Key-Value</code> 对的插入顺序一致</p>
</li>
<li><p><code>HashMap</code>中的内部类：<code>Node</code><br><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183736.png" alt=""></p>
</li>
<li><p><code>LinkedHashMap</code>中的内部类：<code>Entry</code><br><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183740.png" alt=""></p>
</li>
</ul>
<pre><code class="java">/*
 *  四、LinkedHashMap的底层实现原理（了解）
 *      源码中：
 *      static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
 *            Entry&lt;K,V&gt; before, after;//能够记录添加的元素的先后顺序
 *            Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
 *               super(hash, key, value, next);
 *            }
 *        } 
 */
import org.junit.Test;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

public class MapTest {

    @Test
    public void test2(){
        Map map = new HashMap();
        map = new LinkedHashMap();
        map.put(123,&quot;AA&quot;);
        map.put(345,&quot;BB&quot;);
        map.put(12,&quot;CC&quot;);

        System.out.println(map);
    }
}</code></pre>
<h2 id="6-8、Map中的常用方法1"><a href="#6-8、Map中的常用方法1" class="headerlink" title="6.8、Map中的常用方法1"></a>6.8、Map中的常用方法1</h2><pre><code class="java">import org.junit.Test;

import java.util.*;
/**
 *  五、Map中定义的方法：
 *      添加、删除、修改操作：
 *      Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中
 *      void putAll(Map m):将m中的所有key-value对存放到当前map中
 *      Object remove(Object key)：移除指定key的key-value对，并返回value
 *      void clear()：清空当前map中的所有数据
 *      元素查询的操作：
 *      Object get(Object key)：获取指定key对应的value
 *      boolean containsKey(Object key)：是否包含指定的key
 *      boolean containsValue(Object value)：是否包含指定的value
 *      int size()：返回map中key-value对的个数
 *      boolean isEmpty()：判断当前map是否为空
 *      boolean equals(Object obj)：判断当前map和参数对象obj是否相等
 *      元视图操作的方法：
 *      Set keySet()：返回所有key构成的Set集合
 *      Collection values()：返回所有value构成的Collection集合
 *      Set entrySet()：返回所有key-value对构成的Set集合
 *
 */
public class MapTest {

    /**
     *  元素查询的操作：
     *  Object get(Object key)：获取指定key对应的value
     *  boolean containsKey(Object key)：是否包含指定的key
     *  boolean containsValue(Object value)：是否包含指定的value
     *  int size()：返回map中key-value对的个数
     *  boolean isEmpty()：判断当前map是否为空
     *  boolean equals(Object obj)：判断当前map和参数对象obj是否相等
     */
    @Test
    public void test4(){
        Map map = new HashMap();
        map.put(&quot;AA&quot;,123);
        map.put(45,123);
        map.put(&quot;BB&quot;,56);
        // Object get(Object key)
        System.out.println(map.get(45));
        //containsKey(Object key)
        boolean isExist = map.containsKey(&quot;BB&quot;);
        System.out.println(isExist);

        isExist = map.containsValue(123);
        System.out.println(isExist);

        map.clear();

        System.out.println(map.isEmpty());
    }

    /**
     * 添加、删除、修改操作：
     *  Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中
     *  void putAll(Map m):将m中的所有key-value对存放到当前map中
     *  Object remove(Object key)：移除指定key的key-value对，并返回value
     *  void clear()：清空当前map中的所有数据
     */
    @Test
    public void test3(){
        Map map = new HashMap();
        //添加
        map.put(&quot;AA&quot;,123);
        map.put(45,123);
        map.put(&quot;BB&quot;,56);
        //修改
        map.put(&quot;AA&quot;,87);

        System.out.println(map);

        Map map1 = new HashMap();
        map1.put(&quot;CC&quot;,123);
        map1.put(&quot;DD&quot;,456);
        map.putAll(map1);

        System.out.println(map);

        //remove(Object key)
        Object value = map.remove(&quot;CC&quot;);
        System.out.println(value);
        System.out.println(map);

        //clear()
        map.clear();//与map = null操作不同
        System.out.println(map.size());
        System.out.println(map);
    }
}</code></pre>
<h2 id="6-9、Map中的常用方法2"><a href="#6-9、Map中的常用方法2" class="headerlink" title="6.9、Map中的常用方法2"></a>6.9、Map中的常用方法2</h2><pre><code class="java">import org.junit.Test;

import java.util.*;
/**
 *  五、Map中定义的方法：
 *      添加、删除、修改操作：
 *      Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中
 *      void putAll(Map m):将m中的所有key-value对存放到当前map中
 *      Object remove(Object key)：移除指定key的key-value对，并返回value
 *      void clear()：清空当前map中的所有数据
 *      元素查询的操作：
 *      Object get(Object key)：获取指定key对应的value
 *      boolean containsKey(Object key)：是否包含指定的key
 *      boolean containsValue(Object value)：是否包含指定的value
 *      int size()：返回map中key-value对的个数
 *      boolean isEmpty()：判断当前map是否为空
 *      boolean equals(Object obj)：判断当前map和参数对象obj是否相等
 *      元视图操作的方法：
 *      Set keySet()：返回所有key构成的Set集合
 *      Collection values()：返回所有value构成的Collection集合
 *      Set entrySet()：返回所有key-value对构成的Set集合
 *
 * 总结：常用方法：
 *    添加：put(Object key,Object value)
 *    删除：remove(Object key)
 *    修改：put(Object key,Object value)
 *    查询：get(Object key)
 *    长度：size()
 *    遍历：keySet() / values() / entrySet()
 *
 *  面试题：
 *  1. HashMap的底层实现原理？
 *  2. HashMap 和 Hashtable的异同？
 *      1.HashMap与Hashtable都实现了Map接口。由于HashMap的非线程安全性，效率上可能高于Hashtable。Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。
 *      2.HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。
 *      3.HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。
 *      4.Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。
 *      5.Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。
 *
 *  3. CurrentHashMap 与 Hashtable的异同？（暂时不讲）
 *
 */
public class MapTest {

    /**
     *  元视图操作的方法：
     *  Set keySet()：返回所有key构成的Set集合
     *  Collection values()：返回所有value构成的Collection集合
     *  Set entrySet()：返回所有key-value对构成的Set集合
     */
    @Test
    public void test5(){
        Map map = new HashMap();
        map.put(&quot;AA&quot;,123);
        map.put(45,1234);
        map.put(&quot;BB&quot;,56);

        //遍历所有的key集：keySet()
        Set set = map.keySet();
        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
        System.out.println(&quot;*****************&quot;);

        //遍历所有的values集：values()
        Collection values = map.values();
        for(Object obj : values){
            System.out.println(obj);
        }
        System.out.println(&quot;***************&quot;);
        //遍历所有的key-values
        //方式一：
        Set entrySet = map.entrySet();
        Iterator iterator1 = entrySet.iterator();
        while (iterator1.hasNext()){
            Object obj = iterator1.next();
            //entrySet集合中的元素都是entry
            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey() + &quot;----&gt;&quot; + entry.getValue());

        }
        System.out.println(&quot;/&quot;);

        //方式二：
        Set keySet = map.keySet();
        Iterator iterator2 = keySet.iterator();
        while(iterator2.hasNext()){
            Object key = iterator2.next();
            Object value = map.get(key);
            System.out.println(key + &quot;=====&quot; + value);
        }
    }
}</code></pre>
<h2 id="6-10、TreeMap两种添加方式的使用"><a href="#6-10、TreeMap两种添加方式的使用" class="headerlink" title="6.10、TreeMap两种添加方式的使用"></a>6.10、TreeMap两种添加方式的使用</h2><ul>
<li><code>TreeMap</code>存储<code>Key-Value</code> 对时，需要根据<code>key-value</code>对进行排序。<code>TreeMap</code>可以保证所有的<code>Key-Value</code> 对处于<strong>有序</strong>状态。</li>
<li><code>TreeSet</code>底层使用<strong>红黑树</strong>结构存储数据</li>
<li><code>TreeMap</code>的<code>Key</code>的排序：<ul>
<li><strong>自然排序</strong>：<code>TreeMap</code>的所有的<code>Key</code> 必须实现<code>Comparable</code>接口，而且所有的<code>Key</code>应该是同一个类的对象，否则将会抛出<code>ClasssCastException</code></li>
<li><strong>定制排序</strong>：创建<code>TreeMap</code>时，传入一个<code>Comparator</code> 对象，该对象负责对<code>TreeMap</code>中的所有<code>key</code> 进行排序。此时不需要<code>Map</code> 的<code>Key</code>实现<code>Comparable</code> 接口</li>
</ul>
</li>
<li><code>TreeMap</code>判断<strong>两个<code>key</code>相等</strong>的标准：两个<code>key</code>通过<code>compareTo()</code>方法或者<code>compare()</code>方法返回<code>0</code>。</li>
</ul>
<blockquote>
<p>1、User类</p>
</blockquote>
<pre><code class="java">public class User implements Comparable{
    private String name;
    private int age;

    public User() {
    }

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;}&#39;;
    }

    @Override
    public boolean equals(Object o) {
        System.out.println(&quot;User equals()....&quot;);
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        User user = (User) o;

        if (age != user.age) return false;
        return name != null ? name.equals(user.name) : user.name == null;
    }

    @Override
    public int hashCode() { //return name.hashCode() + age;
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }

    //按照姓名从大到小排列,年龄从小到大排列
    @Override
    public int compareTo(Object o) {
        if(o instanceof User){
            User user = (User)o;
//            return -this.name.compareTo(user.name);
            int compare = -this.name.compareTo(user.name);
            if(compare != 0){
                return compare;
            }else{
                return Integer.compare(this.age,user.age);
            }
        }else{
            throw new RuntimeException(&quot;输入的类型不匹配&quot;);
        }

    }
}</code></pre>
<blockquote>
<p>2、测试类</p>
</blockquote>
<pre><code class="java">import org.junit.Test;

import java.util.*;

public class TreeMapTest {

    /**
     * 向TreeMap中添加key-value，要求key必须是由同一个类创建的对象
     * 因为要按照key进行排序：自然排序 、定制排序
     */
    //自然排序
    @Test
    public void test(){
        TreeMap map = new TreeMap();
        User u1 = new User(&quot;Tom&quot;,23);
        User u2 = new User(&quot;Jerry&quot;,32);
        User u3 = new User(&quot;Jack&quot;,20);
        User u4 = new User(&quot;Rose&quot;,18);

        map.put(u1,98);
        map.put(u2,89);
        map.put(u3,76);
        map.put(u4,100);

        Set entrySet = map.entrySet();
        Iterator iterator1 = entrySet.iterator();
        while (iterator1.hasNext()){
            Object obj = iterator1.next();
            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey() + &quot;----&gt;&quot; + entry.getValue());

        }
    }

    //定制排序
    @Test
    public void test2(){
        TreeMap map = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                if(o1 instanceof User &amp;&amp; o2 instanceof User){
                    User u1 = (User)o1;
                    User u2 = (User)o2;
                    return Integer.compare(u1.getAge(),u2.getAge());
                }
                throw new RuntimeException(&quot;输入的类型不匹配！&quot;);
            }
        });
        User u1 = new User(&quot;Tom&quot;,23);
        User u2 = new User(&quot;Jerry&quot;,32);
        User u3 = new User(&quot;Jack&quot;,20);
        User u4 = new User(&quot;Rose&quot;,18);

        map.put(u1,98);
        map.put(u2,89);
        map.put(u3,76);
        map.put(u4,100);

        Set entrySet = map.entrySet();
        Iterator iterator1 = entrySet.iterator();
        while (iterator1.hasNext()){
            Object obj = iterator1.next();
            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey() + &quot;----&gt;&quot; + entry.getValue());

        }
    }
}</code></pre>
<h2 id="6-12、Hashtable"><a href="#6-12、Hashtable" class="headerlink" title="6.12、Hashtable"></a>6.12、Hashtable</h2><ul>
<li><code>Hashtable</code>是个古老的<code>Map</code> 实现类，JDK1.0就提供了。不同于<code>HashMap</code>，<code>Hashtable</code>是线程安全的。</li>
<li><code>Hashtable</code>实现原理和<code>HashMap</code>相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。</li>
<li>与<code>HashMap</code>不同，<strong><code>Hashtable</code>不允许使用<code>null</code> 作为<code>key</code>和<code>value</code></strong></li>
<li>与<code>HashMap</code>一样，<code>Hashtable</code>也不能保证其中<code>Key-Value</code> 对的顺序</li>
<li><code>Hashtable</code>判断两个<code>key</code>相等、两个<code>valu</code>e相等的标准，与<code>HashMap</code>一致。</li>
</ul>
<h2 id="6-13、Properties处理属性文件"><a href="#6-13、Properties处理属性文件" class="headerlink" title="6.13、Properties处理属性文件"></a>6.13、Properties处理属性文件</h2><ul>
<li><code>Properties</code> 类是<code>Hashtable</code>的子类，该对象用于处理属性文件</li>
<li>由于属性文件里的<code>key、value</code>都是字符串类型，所以<strong><code>Properties</code> 里的<code>key</code>和<code>value</code>都是字符串类型</strong></li>
<li>存取数据时，建议使用<code>setProperty(String key,Stringvalue)</code>方法和<code>getProperty(String key)</code>方法</li>
</ul>
<blockquote>
<p>1、新建jdbc.properties文件</p>
</blockquote>
<p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183757.png" alt=""><br><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183804.png" alt=""><br><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183811.png" alt=""></p>
<blockquote>
<p>2、编写源代码</p>
</blockquote>
<pre><code class="java">import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

public class PropertiesTest {
    //Properties:常用来处理配置文件。key和value都是String类型
    public static void main(String[] args){
        //快捷键：ALT+Shift+Z
        FileInputStream fis = null;
        try {
            Properties pros = new Properties();
            fis = new FileInputStream(&quot;jdbc.properties&quot;);
            pros.load(fis); //加载流对应文件

            String name = pros.getProperty(&quot;name&quot;);
            String password = pros.getProperty(&quot;password&quot;);

            System.out.println(&quot;name = &quot; + name + &quot;,password = &quot; + password);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(fis != null){
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}</code></pre>
<blockquote>
<p>如果jdbc.properties文件中写入为中文；</p>
<p>防止jdbc.properties出现中文乱码，可根据如下解决：</p>
</blockquote>
<p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183819.png" alt=""></p>
<blockquote>
<p>新建jdbc.properties</p>
</blockquote>
<p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183826.png" alt=""></p>
<h1 id="07、Collections工具类"><a href="#07、Collections工具类" class="headerlink" title="07、Collections工具类"></a>07、Collections工具类</h1><ul>
<li>操作数组的工具类：<code>Arrays</code></li>
<li><code>Collections</code> 是一个操作<code>Set、List</code>和<code>Map</code> 等集合的工具类</li>
<li><code>Collections</code>中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</li>
<li>排序操作：（均为<code>static</code>方法）<ul>
<li><code>reverse(List)</code>：反转List 中元素的顺序</li>
<li><code>shuffle(List)</code>：对List集合元素进行随机排序</li>
<li><code>sort(List)</code>：根据元素的自然顺序对指定List 集合元素按升序排序</li>
<li><code>sort(List，Comparator)</code>：根据指定的Comparator 产生的顺序对List 集合元素进行排序</li>
<li><code>swap(List，int，int)</code>：将指定list 集合中的i处元素和j 处元素进行交换</li>
</ul>
</li>
</ul>
<h2 id="7-1、Collections工具类常用方法的测试"><a href="#7-1、Collections工具类常用方法的测试" class="headerlink" title="7.1、Collections工具类常用方法的测试"></a>7.1、Collections工具类常用方法的测试</h2><pre><code class="java">import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * Collections:操作Collection、Map的工具类
 *
 * 面试题：Collection 和 Collections的区别？
 *       Collection是集合类的上级接口，继承于他的接口主要有Set 和List.
 *       Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作.
 */
public class CollectionTest {
    /**
     * reverse(List)：反转 List 中元素的顺序
     * shuffle(List)：对 List 集合元素进行随机排序
     * sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序
     * sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序
     * swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换
     *
     * Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素
     * Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素
     * Object min(Collection)
     * Object min(Collection，Comparator)
     * int frequency(Collection，Object)：返回指定集合中指定元素的出现次数
     * void copy(List dest,List src)：将src中的内容复制到dest中
     * boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值
     *
     */

    @Test
    public void test(){
        List list = new ArrayList();
        list.add(123);
        list.add(43);
        list.add(765);
        list.add(765);
        list.add(765);
        list.add(-97);
        list.add(0);

        System.out.println(list);

//        Collections.reverse(list);
//        Collections.shuffle(list);
//        Collections.sort(list);
//        Collections.swap(list,1,2);
        int frequency = Collections.frequency(list, 123);

        System.out.println(list);
        System.out.println(frequency);
    }

    @Test
    public void test2(){
        List list = new ArrayList();
        list.add(123);
        list.add(43);
        list.add(765);
        list.add(-97);
        list.add(0);

        //报异常：IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;)
//        List dest = new ArrayList();
//        Collections.copy(dest,list);
        //正确的：
        List dest = Arrays.asList(new Object[list.size()]);
        System.out.println(dest.size());//list.size();
        Collections.copy(dest,list);

        System.out.println(dest);

        /**
         * Collections 类中提供了多个 synchronizedXxx() 方法，
         * 该方法可使将指定集合包装成线程同步的集合，从而可以解决
         * 多线程并发访问集合时的线程安全问题
         */
        //返回的list1即为线程安全的List
        List list1 = Collections.synchronizedList(list);
    }
}</code></pre>
<h2 id="7-2、补充：Enumeration-了解！！！"><a href="#7-2、补充：Enumeration-了解！！！" class="headerlink" title="7.2、补充：Enumeration(了解！！！)"></a>7.2、补充：Enumeration(了解！！！)</h2><ul>
<li><code>Enumeration</code> 接口是<code>Iterator</code>迭代器的“古老版本”</li>
</ul>
<p><img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2021/01/16/20210119183836.png" alt=""></p>
<pre><code class="java">Enumeration stringEnum = new StringTokenizer(&quot;a-b*c-d-e-g&quot;, &quot;-&quot;);
    while(stringEnum.hasMoreElements()){
        Object obj= stringEnum.nextElement();System.out.println(obj); 
    }</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源。 </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>13集合</p>
    <p><span class="copy-title">字数:</span><span class="post-count">16.8k</span></p>
    <p><span class="copy-title">本文作者:</span><a  title="程序员卖剩鸭">程序员卖剩鸭</a></p>
    <p><span class="copy-title">发布时间:</span>2020-07-27, 00:00:00</p>
    <p><span class="copy-title">最后更新:</span>2022-11-19, 22:57:15</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/post/d76a15aa.html" title="13集合">http://lsqstudy.github.io/post/d76a15aa.html</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="CC BY-NC-SA 4.0 International" target = "_blank">&#34;署名-非商用-相同方式共享 4.0&#34;</a> 转载请保留原文链接及作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry"><span class="miit">
                <img src="/img/gov.png" title="中华人民共和国工业和信息化部">
                <a href="http://beian.miit.gov.cn/" target="_blank" rel="noopener">粤ICP备20031985号</a>
        </span>
    
    ©2019-2022 程序员卖剩鸭
</p>
<p class="footer-entry">活到老，学到老，别想偷懒！</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2020/04/17/20200418164902.png" class="alipay" title="扫码支持">
            <img src="https://gitcode.net/PorkBird/lsq20220804_picturebed/-/raw/master/img/2020/04/17/20200418164901.png" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 579px;
    }
    .nav.fullscreen {
        margin-left: -579px;
    }
    .nav-left {
        width: 157px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 527px;
        }
        .nav.fullscreen {
            margin-left: -527px;
        }
        .nav-left {
            width: 135px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 527px;
            margin-left: -527px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #c1bfc1;
    }
    
    
    .nav-right nav a.hover > span{
        color: #ffffff !important;
    }
    

    /*列表样式*/
    
    #post .pjax article .article-entry>ol, #post .pjax article .article-entry>ul, #post .pjax article>ol, #post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    #post .pjax article .article-entry li>ol, #post .pjax article .article-entry li>ul,#post .pjax article li>ol, #post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    #post .pjax article .article-entry>ol>li, #post .pjax article .article-entry>ul>li,#post .pjax article>ol>li, #post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    #post .pjax article .article-entry li>ol>li, #post .pjax article .article-entry li>ul>li,#post .pjax article li>ol>li, #post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
    #post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>
